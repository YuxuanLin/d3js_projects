<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: auto;
  position: relative;
  width: 960px;
}

form {
  position: absolute;
  right: 10px;
  top: 10px;
}

path {
  stroke: #fff;
  fill-rule: evenodd;
}

</style>
<body>
<form>
  <label><input type="radio" name="mode" value="size" > Size</label>
  <label><input type="radio" name="mode" value="count" checked> Count</label>
</form>
<script src="d3.min.js"></script>
<script>
var formatNumber = d3.format(",d");
var width = 960,
    height = 700,
    radius = Math.min(width-50, height-50) / 2;

var xScale = d3.scale.linear()
    .range([0, 2 * Math.PI]);// Set the ranges(output size)

var yScale = d3.scale.sqrt()
    .range([0, radius]);// Set the ranges(output size)

var color = d3.scale.category20c();//set color scheme

var svg = d3.select("body").append("svg")//create a svg selection
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", "translate(" + width / 2 + "," + (height / 2 + 10) + ")");

var partition = d3.layout.partition()//create a partition canvas
    .sort(null)//defaults to descending order by the associated input data's numeric value attribute
    .value(function(d) { return 1; });//设置读数器 ?

var arc = d3.svg.arc()
    .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, xScale(d.x))); })// set 
    .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, xScale(d.x + d.dx))); })
    .innerRadius(function(d) { return Math.max(0, yScale(d.y)); })//set 内半径accesser
    .outerRadius(function(d) { return Math.max(0, yScale(d.y + d.dy)); });//set 外半径accesser

// Keep track of the node that is currently being displayed as the root.
var nodeRoot;

d3.json("./flare.json", function(error, root) {
    nodeRoot = root;
    var path = svg.datum(root).selectAll("path")// create path elements
        .data(partition.nodes)//bond data to path elements,returning the array of nodes associated with the specified root node. 
        .enter().append("path")//新增path元素
        .attr("d", arc)//设置形状
        .style("fill", function(d) { return color((d.children ? d : d.parent).name); })//设置颜色
        .on("click", click)//设置动作
        .each(stash)//using .each() you get access to 3 things you need: d, this and i. 好像并不影响效果
      ;

    path
        .append("title")
        .text(function(d) { return d.name + "\n" + "Contains "+ formatNumber(d.value); });
    

    d3.selectAll("input").on("change", function change() {//add or remove a listener
        var value = this.value === "count"
            ? function() { return 1; }//如果选定的是个数，定义function：每个扇区大小为1
            : function(d) { return d.size; };//如果选定的是size，定义function：每个扇区大小为size

        path
            .data(partition.value(value).nodes)
            .transition()
            .duration(1000)
            .attrTween("d", arcTweenData)
            ;
            //数值变化时图形映射
    });

    function click(d) {
        nodeRoot = d;
        path.transition()
            .duration(1000)
            .attrTween("d", arcTweenZoom(d));//数值变化时图形映射
    }
});

d3.select(self.frameElement).style("height", height + "px");

// Setup for switching data: stash the old values for transition.
function stash(d) {//好像并不影响效果，最后再看
    d.x0 = d.x;//x - the minimum x-coordinate of the node position.
    d.dx0 = d.dx;//dx - the x-extent(延伸) of the node position.
}

// When switching data: interpolate the arcs in data space.
function arcTweenData(a, i) {
    var oi = d3.interpolate({x: a.x0, dx: a.dx0}, a);
    function tween(t) {
        var b = oi(t);
        a.x0 = b.x;
        a.dx0 = b.dx;
        return arc(b);
    }
    if (i == 0) {
   // If we are on the first arc, adjust the x domain to match the root node
   // at the current zoom level. (We only need to do this once.)
        var xd = d3.interpolate(xScale.domain(), [nodeRoot.x, nodeRoot.x + nodeRoot.dx]);
        return function(t) {
            xScale.domain(xd(t));
            return tween(t);
        };
    } else {
        return tween;
    }
}

// When zooming: interpolate the scales.
function arcTweenZoom(d) {
    var xd = d3.interpolate(xScale.domain(), [d.x, d.x + d.dx]),
        yd = d3.interpolate(yScale.domain(), [d.y, 1]),//y - the minimum y-coordinate of the node position.
        yr = d3.interpolate(yScale.range(), [d.y ? 20 : 0, radius]);
    return function(d, i) {
        return i
            ? function(t) { return arc(d); }
            : function(t) { xScale.domain(xd(t)); yScale.domain(yd(t)).range(yr(t)); return arc(d); };
    };
}

</script>