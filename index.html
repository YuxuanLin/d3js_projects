<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: auto;
  position: relative;
  width: 960px;
  font-size: 
}
#explanation {
  position: absolute;
  top: 300px;
  left:10px;
  width: 140px;
  text-align: center;
  color: #666;
  z-index: -1;
}
h1 {
    font-size: 240%;
}
p {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 200%;
}
#sequence text, #legend text {
  font-weight: 600;
  fill: #fff;
}
#sequence {/* id selector*/
  width: 600px;
  height: 70px;
}
path {/*point to path element*/
  stroke: #fff;
  fill-rule: evenodd;
}
#chart {
    border-style: solid;
    margin-bottom: 30px;
    border-width: 1px;
    border-color: rgb(238,238,238);
}
</style>
<html>
<body>
<br>
<h1>Greenhouse gases generated by Melbourne Council
</h1>
<div id="sequence"></div>
<script src="d3.min.js"></script>
<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
  <div id="chart">
    <div id="explanation" >
      <!-- <span id="rank" ></span> -->
      <font id="rank" size="19"   text-align: center></font><br/>
    </div>
  </div>
  <div>
    <p >
      Please move mouse to play around, click the arc to zoom in,  and click centre to zoom out.
    </p>
  </div>
<script>
var formatNumber = d3.format(",d");
var width = 960,
  height = 700,
  radius = Math.min(width-50, height-50) / 2;

var xScale = d3.scale.linear()
  .range([0, 2 * Math.PI]);// Set the ranges(output size)
var yScale = d3.scale.sqrt()
  .range([0, radius]);// Set the ranges(output size)
var b = {w: 75, h: 30, s: 3, t: 10};

//Set color scale for each branch
var color1 = d3.scale.linear().range(colorbrewer.BuGn[5].slice(3)).domain([3,2,1]);
var color2 = d3.scale.linear().range(colorbrewer.BuPu[5].slice(3)).domain([3,2,1]);
var color3 = d3.scale.linear().range(colorbrewer.GnBu[5].slice(3)).domain([3,2,1]);
var color4 = d3.scale.linear().range(colorbrewer.OrRd[5].slice(3)).domain([3,2,1]);
var color5 = d3.scale.linear().range(colorbrewer.PuBuGn[6].slice(3)).domain([3,2,1]);
var color6 = d3.scale.linear().range(colorbrewer.PuRd[6].slice(3)).domain([3,2,1]);
var color7 = d3.scale.linear().range(colorbrewer.RdPu[5].slice(3)).domain([3,2,1]);
var color8 = d3.scale.linear().range(colorbrewer.YlGnBu[5].slice(3)).domain([3,2,1]);
var color9 = d3.scale.linear().range(colorbrewer.YlOrBr[5].slice(3)).domain([3,2,1]);
var color10 = d3.scale.linear().range(colorbrewer.YlOrRd[5].slice(3)).domain([3,2,1]);
var color11 = d3.scale.linear().range(colorbrewer.Oranges[5].slice(3)).domain([3,2,1]);

//create a svg from #id selector
var svg = d3.select("#chart").append("svg")
  .attr("width", width)
  .attr("height", height)
  .attr("id", "container")
  .append("g")
  .attr("transform", "translate(" + width / 2 + "," + (height / 2 + 10) + ")");


var partition = d3.layout.partition()//create a partition canvas
  .sort(null)
  .value(function(d) { return d.size; })
  ;

//arc creater
var arc = d3.svg.arc()
  .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, xScale(d.x))); }) 
  .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, xScale(d.x + d.dx))); })
  .innerRadius(function(d) { return Math.max(0, yScale(d.y )); })//inner radius
  .outerRadius(function(d) { return Math.max(0, yScale(d.y  + d.dy)); });//outer radius

svg.append("circle")
  .attr("r", radius)
  .style("opacity", 0);

// Keep track of the node that is currently being displayed as the root.
var nodeRoot;

//Used to calculate the percentage, very important
var totalSize = 0;

//Read JSON into D3
d3.json("./council-data.json", function(error, root) {

    nodeRoot = root;
    // create path elements
    var path = svg.datum(root).selectAll("path")
      .data(partition.nodes) 
    .enter().append("path")//add path
      .attr("d", arc)//set arc
      .style("fill", pickColor)
      .on("click", click)//Add motion
    ;
    
    //Add motion
    path
      .style("opacity", 1)
      .on("mouseover", mouseover)
      ;//0 for most opacity and 1 for no opacity
    
    //Add motion
    d3.select("#container").on("mouseleave", mouseleave);

    path
      .append("title")
      .text(function(d) { 
        if(d.depth == 3){
          return d.name + "\n" + "CO2 Emission: "+ formatNumber(d.size);
        }else if (d.depth == 2){
          return d.name + "\n" + "Contains emission records: "+ formatNumber(d.children.length);
        }else if (d.depth == 1){
          return d.name + "\n" + "Contains assets: "+ formatNumber(d.children.length);
        }else if(d.depth == 0){
          return d.name + "\n" + "Contains branches: "+ formatNumber(d.children.length);
        }
      });
    
    initializeBreadcrumbTrail();
    totalSize = path.node().__data__.value;

    function click(d) {
      nodeRoot = d;
      path.transition()
        .duration(1000)
        .attrTween("d", arcTweenZoom(d));//change node
    }

});

//Choose color from different colorbrewer
function pickColor(d) { 
  var fatherName;
  var myColorbrewer;
  //decide which colorbrewer with name
  switch(d.depth) {
    case 0:
      fatherName = d.name;
      break;
    case 1:
      fatherName = d.name;
      break;
    case 2:
      fatherName = d.parent.name;
      break;
    case 3:
      fatherName = d.parent.parent.name;
      break;
  }
  //Pick color with depth
  switch(fatherName){
    case "Arts and Culture":
      return color1(d.depth);
      break;
    case "Community Services":
      return color2(d.depth);
      break;
    case "Community Strengthening":
      return color3(d.depth);
      break;
    case "Customer Relations":
      return color4(d.depth);
      break;
    case "Engineering Services":
      return color5(d.depth);
      break;
    case "Events Melbourne":
      return color6(d.depth);
      break;
    case "Park Services including Waterways":
      return color7(d.depth);
      break;
    case "Property Services":
      return color8(d.depth);
      break;
    case "Recreation Services":
      return color9(d.depth);
      break;
    case "Supply Chain":
      return color10(d.depth);
      break;
    case "Tourism Melbourne":
      return color11(d.depth);
      break;
    default:
      return "transparent";
  }
}

// Generate a string that describes the points of a breadcrumb polygon.
function breadcrumbPoints(d, i) {
  var points = [];
  points.push("0,0"); // 左上
  // console.log(d.name.length);//4 20 21 17
  b.w = getLength(d.name.length);
  points.push(b.w + ",0"); //右上
  points.push(b.w + b.t + "," + (b.h / 2));//右中
  points.push(b.w + "," + b.h);//右下
  points.push("0," + b.h);//左下
  if (i > 1) { // Leftmost breadcrumb; don't include 6th vertex.
    points.push(b.t + "," + (b.h / 2));
  }
  return points.join(" ");
}

//Translate the length of a string into a suitable length for trail
function getLength(length){
  return length * 10 + 10;
}


function updateBreadcrumbs(nodeArray, percentageString) {

  var lengthsHistory = [];
  var totalLength = 0;
  for (var i = 0; i < nodeArray.length-1; i ++){
    lengthsHistory[i] = getLength(nodeArray[i].name.length);
    totalLength += getLength(nodeArray[i].name.length);
  }
  totalLength += getLength(nodeArray[nodeArray.length-1].name.length);
  
  // Data join; key function combines name and depth (= position in sequence).
  var g = d3.select("#trail")
    .selectAll("g")
    .data(nodeArray, function(d) { return d.name + d.depth; });
  
  // Add breadcrumb and label for entering nodes.
  var entering = g.enter().append("svg:g");

  entering.append("svg:polygon")
    .attr("points", breadcrumbPoints)
    .style("fill", pickColor);//TODO

  entering.append("svg:text")
    .attr("x", function(d){ return (getLength(d.name.length)+ b.t ) / 2})//todo
    .attr("y", b.h / 2)
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .text(function(d) { return d.name;});
  
  // Set position for entering and updating nodes.
  g.attr("transform", function(d, i) {
    var shift = 0;
    for(var n = 0; n < i; n++){// -1 to avoid plusing itself's length
      shift += lengthsHistory[n]; 
    }
    return "translate(" +  (shift + i * 4) + ", 0)";//TODO
  });

  // Remove exiting nodes.
  g.exit().remove();

  //Now move and update the percentage at the end.
  d3.select("#trail").select("#endlabel")
    .attr("x", totalLength + 50)//TODO
    .attr("y", b.h /2 )
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .text(percentageString);

  // Make the breadcrumb trail visible, if it's hidden.
  d3.select("#trail")
    .style("visibility", "");

}

function initializeBreadcrumbTrail() {
  // Add the svg area.
  var trail = d3.select("#sequence").append("svg:svg")
    .attr("width", width)
    .attr("height", 50)
    .attr("id", "trail");
  // Add the label at the end, for the percentage.
  trail.append("svg:text")
    .attr("id", "endlabel")
    .style("fill", "#000");
}

function mouseover(d) {

  var percentage = (100 * d.value / totalSize).toPrecision(3);
  var percentageString = percentage + "%";
  if (percentage < 0.1) {
    percentageString = "< 0.1%";
  }
  var rank;
  switch(d.depth){
    case 1:
      rank = "BRANCH";
      break;
    case 2:
      rank = "ASSET";
      break;
    case 3:
      rank = "RECORD"
      break;
    default:
      break;
  }

  d3.select("#rank")
    .text(rank);

  d3.select("#explanation")
    .style("visibility", "");

  var sequenceArray = getAncestors(d);
  updateBreadcrumbs(sequenceArray, percentageString);

  // Fade all the segments.
  d3.selectAll("path")
    .style("opacity", 0.3);

  // Then highlight only those that are an ancestor of the current segment.
  svg.selectAll("path")
    .filter(function(node) {return (sequenceArray.indexOf(node) >= 0);})
    .style("opacity", 1);
}

// Restore everything to full opacity when moving off the visualization.
function mouseleave(d) {

  // Hide the breadcrumb trail
  d3.select("#trail")
    .style("visibility", "hidden");

  // Deactivate all segments during transition.
  d3.selectAll("path").on("mouseover", null);

  // Transition each segment to full opacity and then reactivate it.
  d3.selectAll("path")
    .transition()
    .duration(200)
    .style("opacity", 1)
    .each("end", function() {
      d3.select(this).on("mouseover", mouseover);
    });

  d3.select("#explanation")
    .style("visibility", "hidden");
}

// Given a node in a partition layout, return an array of all of its ancestor
// nodes, highest first, but excluding the root.
function getAncestors(node) {
  var path = [];
  var current = node;
  while (current.depth >= 0) {
    path.unshift(current);
    if(current.parent)
        current = current.parent;
    else
        break;
  }
  return path;
}

d3.select(self.frameElement).style("height", 20000 + "px");

// When zooming: interpolate the scales.
function arcTweenZoom(d) {
  var xd = d3.interpolate(xScale.domain(), [d.x, d.x + d.dx]),// map (0,1) --> (a,b)
    yd = d3.interpolate(yScale.domain(), [d.y, 1]),//y - the minimum y-coordinate of the node position.
    yr = d3.interpolate(yScale.range(), [d.y ? 20 : 0, radius]);
 
  return function(d, i) {//current datum d, the current index i and the current attribute value a
    return i
      ? function(t) { return arc(d); }
      : function(t) { 
        xScale.domain(xd(t)); //change input domain
        yScale.domain(yd(t)).range(yr(t)); 
        return arc(d); 
      };
  };
}
</script>
</body>
</html>